import django_filters
from rest_framework.utils.serializer_helpers import BindingDict

from django.contrib.contenttypes.models import ContentType
from django.db.utils import ProgrammingError

from abas.utils.api.drf.filters import SearchFilter

from ...userdefinedfields.models import ExtraField
from .fields import CustomFieldField


class CustomFieldFilterMixin:
    """ Mixin for automatically adding custom fields filtering
    Generated by looking up the ExtraFields associated with the Meta model's ContentType.
    """

    custom_fields_key = 'extra_fields'

    @classmethod
    def get_filters(cls):
        filters = super(CustomFieldFilterMixin, cls).get_filters()
        try:
            ct = ContentType.objects.get_for_model(cls._meta.model)
        except ProgrammingError:
            # We don't have an initialised database yet, so we can't access
            # the ContentType table. Abort.
            return {}

        extra_fields = ExtraField.objects.filter(content_type=ct)
        for field in extra_fields:
            db_field_name = f'{cls.custom_fields_key}__{field.name}'
            if field.widget == 'text' or field.widget == 'multiline-text':
                filters[field.name] = SearchFilter(
                    label=field.label,
                    fields=[db_field_name],
                    comparison='contains',
                )
            elif field.widget == 'integer':
                filters[field.name] = django_filters.NumberFilter(field_name=db_field_name, label=field.label)
            elif field.widget == 'date':
                filters[field.name] = django_filters.DateFilter(field_name=db_field_name, label=field.label)
            elif field.widget == 'choice':
                validated_choices = []
                choices = field.field_settings.get('choices', [])
                if isinstance(choices, list):
                    for choice in choices:
                        if isinstance(choice, dict):
                            validated_choices.append((choice.get('value'), choice.get('label')))
                choice = django_filters.ChoiceFilter(choices=validated_choices, label=field.label)
                choice.name = db_field_name
                filters[field.name] = choice
        return filters


class CustomFieldFilterViewSetMixin:
    extra_fields_qarg = 'extra_fields__'
    extra_fields_filters = {}

    def get_queryset(self, *args, **kwargs):
        qs = super().get_queryset(*args, **kwargs)
        for key, value in self.extra_fields_filters.items():
            qs = qs.filter(**{'extra_fields__%s' % key: value})
        return qs

    def dispatch(self, request, *args, **kwargs):
        self.extra_fields_filters = {}
        for qarg in request.GET.items():
            if qarg[0].startswith(self.extra_fields_qarg):
                key = qarg[0][len(self.extra_fields_qarg):]
                self.extra_fields_filters[key] = request.GET.get(qarg[0])
        return super().dispatch(request, *args, **kwargs)


class CustomFieldCSVSerializerMixin:
    """
    This allows all 'extra_fields' json blobs saved against a model to
    come through to a CSV download in its own column.
    """
    def __init__(self, *args, **kwargs):
        for efield in self.get_extra_fields():
            self.csv_config['header'].append((f'extra_fields_{efield.name}', efield.label))
        super().__init__(*args, **kwargs)

        # The init method is called more than once throughout our custom drf code (so make sure we de-dupe, PRESERVING ORDER)
        # TODO: Find a better way to do this. Shouldn't be getting dupes here in the first place.
        self.csv_config['header'] = list(dict.fromkeys(self.csv_config['header']))

    def get_extra_fields(self):
        content_type = ContentType.objects.get_for_model(self.Meta.model)
        extra_fields = ExtraField.objects.filter(content_type=content_type)

        return extra_fields

    @property
    def fields(self):
        """
        A dictionary of {field_name: field_instance}.
        """
        # subclassing drf fields method to include our extra_fields data.
        # Please note: Calling to super will incur a BindingDict error so we ... dont.
        if not hasattr(self, '_fields'):
            self._fields = BindingDict(self)
            for key, value in self.get_fields().items():
                self._fields[key] = value

            for efield in self.get_extra_fields():
                # named extra field to match the importer tool
                self._fields[f'extra_fields_{efield.name}'] = CustomFieldField(label=efield.label, source=efield.name)

        return self._fields
